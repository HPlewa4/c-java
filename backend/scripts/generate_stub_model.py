#!/usr/bin/env python3
"""Utility for generating a tiny placeholder model.

The generated binary mirrors the layout expected by NeuralNetwork::load
so the server can start even when a real trained model is absent.
"""

from __future__ import annotations

import argparse
import os
import random
import struct
from pathlib import Path
from typing import List


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate a stub neural network model")
    parser.add_argument(
        "--model", required=True, help="Path to the model binary to create"
    )
    parser.add_argument(
        "--classes", help="Optional classes.txt path to create if missing"
    )
    parser.add_argument("--input-dim", type=int, default=1024, help="Input layer size")
    parser.add_argument("--hidden-dim", type=int, default=128, help="Hidden layer size")
    parser.add_argument(
        "--num-classes",
        type=int,
        default=5,
        help="Number of output classes if the file does not exist",
    )
    parser.add_argument(
        "--class-prefix", default="class_", help="Prefix for autogenerated class names"
    )
    parser.add_argument(
        "--learning-rate",
        type=float,
        default=0.01,
        help="Learning rate to embed in the model file",
    )
    return parser.parse_args()


def ensure_class_names(path: Path | None, count: int, prefix: str) -> List[str]:
    if path is None:
        return [f"{prefix}{idx}" for idx in range(count)]

    if path.exists() and path.stat().st_size > 0:
        with path.open("r", encoding="utf-8") as handle:
            names = [line.strip() for line in handle if line.strip()]
        if names:
            return names

    path.parent.mkdir(parents=True, exist_ok=True)
    names = [f"{prefix}{idx}" for idx in range(count)]
    with path.open("w", encoding="utf-8") as handle:
        handle.write("\n".join(names) + "\n")
    return names


def write_doubles(handle, values: List[float]) -> None:
    if not values:
        return
    handle.write(struct.pack("<" + "d" * len(values), *values))


def write_stub_model(model_path: Path, layers: List[int], learning_rate: float) -> None:
    rng = random.Random(42)
    model_path.parent.mkdir(parents=True, exist_ok=True)

    with model_path.open("wb") as handle:
        handle.write(struct.pack("<Q", len(layers)))
        handle.write(struct.pack("<" + "i" * len(layers), *layers))
        handle.write(struct.pack("<d", learning_rate))

        for idx in range(len(layers) - 1):
            in_size = layers[idx]
            out_size = layers[idx + 1]
            for _ in range(out_size):
                weights = [rng.uniform(-0.05, 0.05) for _ in range(in_size)]
                write_doubles(handle, weights)
            biases = [0.0] * out_size
            write_doubles(handle, biases)


def main() -> None:
    args = parse_args()
    classes_path = Path(args.classes) if args.classes else None
    class_names = ensure_class_names(classes_path, args.num_classes, args.class_prefix)
    layers = [args.input_dim, args.hidden_dim, len(class_names)]
    write_stub_model(Path(args.model), layers, args.learning_rate)


if __name__ == "__main__":
    main()
